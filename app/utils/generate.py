from fernet import Fernet

DATE_WEEK = ["Пн", "Вт", "Ср", "Чт", "Пт",]

MONTHS = {
    "01": "Январь",
    "02": "Февраль",
    "03": "Март",
    "04": "Апрель",
    "05": "Май",
    "06": "Июнь",
    "07": "Июль",
    "08": "Август",
    "09": "Сентябрь",
    "10": "Октябрь",
    "11": "Ноябрь",
    "12": "Декабрь",
}

FAQ = {
    "Что умеет бот": [
        "Бот помогает подготовить письма и автоматически отправлять их в нужную дату выбранным получателям (контрагентам).",
        "Главное меню: Профиль, Календарь, Контрагенты.",
    ],
    "Быстрый старт": [
        "Нажмите /start.",
        "Если профиля нет — создайте профиль (без него отправка не работает).",
        "Добавьте получателей в «Контрагенты».",
        "Зайдите в «Календарь» → выберите год/месяц → день → «Заполнить дату» (тема + текст).",
        "Откройте созданную дату (в календаре она отмечена ✅) → «Добавить» → выберите контрагентов.",
    ],
    "Профиль": [
        "Зачем нужен: хранит данные отправителя (имя отправителя, почта, пароль). Без профиля рассылка не работает.",
        "Как создать/изменить: Главное меню → «Профиль» → «Создать/Изменить профиль» → введите имя → почту → пароль.",
        "Проверка: «Отправить тестовое сообщение» → введите email получателя → получите статус отправки.",
        "Важно: отправка настроена через SMTP smtp.mail.ru, поэтому стабильнее с почтой Mail.ru (для других сервисов может не работать без донастройки).",
    ],
    "Контрагенты": [
        "Кто это: получатели писем (имя + контактные данные, обычно email).",
        "Как добавить: «Контрагенты» → «Создать контрагента» → имя → почта.",
        "Редактирование: сейчас не предусмотрено; если ошиблись — удалите и создайте заново. ВАЖНО: При удалении контрагента, все его связи с датами тоже удаляются",
        "Ограничение: имя контрагента должно быть уникальным.",
        "Удаление: откройте контрагента → «Удалить» (при необходимости заранее отвяжите от дат).",
    ],
    "Календарь и даты": [
        "Дата в календаре — это событие рассылки: дата отправки + тема + текст + список контрагентов.",
        "Одна и та же дата не может повторяться (уникальная дата).",
        "Обозначения: ✅число — дата создана; обычное число — свободно; ❌ — не относится к месяцу.",
        "Как создать дату: Календарь → год → месяц → день → «Заполнить дату» → введите тему → введите текст.",
        "Шаблоны в тексте: используйте {имя}, {почта}, {дата}. Пример: 'Здравствуйте, {имя}! Напоминаю про {дата}.'",
        "Как привязать контрагентов: откройте дату → «Добавить» → выберите контрагентов (можно сколько угодно).",
        "Как отвязать: откройте дату → нажмите на имя контрагента в списке внутри даты.",
        "Как изменить тему/текст: сейчас нельзя; удалите дату и создайте заново.",
    ],
    "Отправка писем": [
        "Бот проверяет отправку каждые 15 минут и отправляет письма для сегодняшней даты (по TIME_ZONE). Проверка проходит в период 12-22 часов",
        "Повторно одно и то же письмо одному контрагенту по этой дате не отправляется (помечается как отправленное).",
        "Если к дате не привязаны контрагенты — отправки не будет.",
        "Прошлые даты автоматически не отправляются — используйте будущие даты.",
    ],
    "Частые проблемы": [
        "Письмо не пришло: проверьте профиль и тестовую отправку; привязку контрагента к нужной дате; что сегодня именно эта дата; дождитесь очередной проверки (не мгновенно).",
        "Контрагент не добавился: имя должно быть уникальным.",
        "Нужно исправить тему/текст даты: удалите дату и создайте заново. (В скором времени добавлю функционал для изменения)",
    ],
}

FAQ_KEYS = list(FAQ.keys())

class EmailCrypto:
    def __init__(self, secret_key):
        self.f = Fernet(secret_key)
        
    def encrypt_password(self, email_password: str) -> str:
        return self.f.encrypt(email_password.encode("utf-8")).decode("utf-8")

    def decrypt_password(self, token: str) -> str:
        return self.f.decrypt(token.encode("utf-8")).decode("utf-8")

# async def gen(*, year):
#     tz = timezone(tz_name)
#     tod = datetime.now(tz=tz).date()
#     res = list()
#     if tod.year != year:
#         for month in range(1, 13):
#             cal = calendar.Calendar(0).itermonthdates(year, month)
            
#             for date in cal:
#                 if date.month == month:
                    